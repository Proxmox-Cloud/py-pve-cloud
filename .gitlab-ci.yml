rc_tag:
  stage: build
  image: docker.io/tobiashvmz/pve-cloud-ci:2025122115
  script:
    - |
      # set config based on the current commit for auto commit
      git config --global user.name "$GITLAB_USER_NAME"
      git config --global user.email "$GITLAB_USER_EMAIL"

      # get the latest full release tag => default to 0.0.0
      tags=$(git tag -l | grep -E '^[0-9]+\.[0-9]+\.[0-9]+$' || true)
      if [ -z "$tags" ]; then
        latest_tag="0.0.0"
      else
        latest_tag=$(echo "$tags" | sort -V | tail -n 1)
      fi

      # split the tag and increment
      major=$(echo "$latest_tag" | cut -d '.' -f 1)
      minor=$(echo "$latest_tag" | cut -d '.' -f 2)
      patch=$(echo "$latest_tag" | cut -d '.' -f 3)

      if [[ "$CI_COMMIT_TAG" == *"-major" ]]; then
        major=$((major + 1))
        minor=0
        patch=0
      elif [[ "$CI_COMMIT_TAG" == *"-minor" ]]; then
        minor=$((minor + 1))
        patch=0
      elif [[ "$CI_COMMIT_TAG" == *"-patch" ]]; then
        patch=$((patch + 1))
      else
        echo "Unknown increment type: $CI_COMMIT_TAG"
        exit 1
      fi

      new_tag="$major.$minor.$patch"

      # check if rc tag exists
      rc_tags=$(git tag -l | grep -E "^${new_tag}-rc[0-9]+$" || true)

      # create / increment
      if [ -z "$rc_tags" ]; then
        rc_tag="${new_tag}-rc0"
      else
        latest_rc=$(echo "$rc_tags" | sort -V | tail -n 1)
        rc_num=${latest_rc##*-rc}   # removes everything up to last "-rc"
        
        next_rc=$((rc_num + 1))
        
        rc_tag="${new_tag}-rc${next_rc}"
      fi

      echo "Next RC tag: $rc_tag"

      git tag "$rc_tag" -m "$CI_COMMIT_TAG" # create the rc tag
      git push origin "$rc_tag" # push the tag

      sleep 10 # ci wait

      # trigger whatever release pipelines
      curl --request POST \
        --form "token=${CI_JOB_TOKEN}" \
        --form "ref=${rc_tag}" \
        "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/trigger/pipeline"

  rules:
    - if: '$CI_COMMIT_TAG =~ /^rc-[a-z]+$/'
  resource_group: deploy-prod


release_tag:
  stage: build
  image: docker.io/tobiashvmz/pve-cloud-ci:2025122115
  script:
    - pwd
    - /scripts/release-tag.sh
  rules:
    - if: '$CI_COMMIT_TAG =~ /^release-[a-z]+$/'
    - if: '$CI_COMMIT_TAG =~ /^release-all-[a-z]+$/'
  resource_group: deploy-prod


# called by curl post, could also be called manually but creating
# release-patch... is much easier
publish_pypi:
  stage: deploy
  image:
    name: tobiashvmz/pve-cloud-pyci:2026010412
  script:
    - echo "__version__ = \"${CI_COMMIT_TAG//-/}\"" > src/pve_cloud/_version.py # dynamic versioning, remove - from rc tags for pypi versioning
    - python3 -m build
    - python3 -m twine upload dist/* -u __token__ -p $PYPI_TOKEN # skip gitlab oidc twine feature with -u and -p flags

    # curl loop wait for it to be accessible
    - |
      for i in {1..60}; do
        if curl -s https://pypi.org/simple/py-pve-cloud/ | grep -q "py_pve_cloud-${CI_COMMIT_TAG//-/}.tar.gz"; then
          echo "exists!"
          exit 0
        fi
        echo "Waitingâ€¦ ($i/60)"
        sleep 10
      done
      echo "timeout!"
      exit 1

    # todo: implement offline boostrap / self hosted registry approach
  rules:
    - if: '$CI_COMMIT_TAG =~ /^\d+\.\d+\.\d+$/' # semver
    - if: '$CI_COMMIT_TAG =~ /^\d+\.\d+\.\d+-rc\d+$/' # rcs

# after building here we trigger downstream pipelines now
downstream_controller:
  stage: deploy
  needs:
    - publish_pypi
  trigger:
    project: "pve-cloud/pve-cloud-controller"
  variables:
    PY_PVE_CLOUD: $CI_COMMIT_TAG
    UPSTREAM_TAG_MESSAGE: $CI_COMMIT_TAG_MESSAGE # here we store the type of the release
  rules:
    - if: '$CI_COMMIT_TAG =~ /^\d+\.\d+\.\d+$/' # semver
    - if: '$CI_COMMIT_TAG =~ /^\d+\.\d+\.\d+-rc\d+$/' # rcs

downstream_backup:
  stage: deploy
  needs:
    - publish_pypi
  trigger:
    project: "pve-cloud/pve-cloud-backup"
  variables:
    PY_PVE_CLOUD: $CI_COMMIT_TAG
    UPSTREAM_TAG_MESSAGE: $CI_COMMIT_TAG_MESSAGE # here we store the type of the release
  rules:
    - if: '$CI_COMMIT_TAG =~ /^\d+\.\d+\.\d+$/' # semver

downstream_pve_cloud:
  stage: deploy
  needs:
    - publish_pypi
  trigger:
    project: "pve-cloud/pve_cloud"
  variables:
    PY_PVE_CLOUD: $CI_COMMIT_TAG
    UPSTREAM_TAG_MESSAGE: $CI_COMMIT_TAG_MESSAGE # here we store the type of the release
  rules:
    - if: '$CI_COMMIT_TAG =~ /^\d+\.\d+\.\d+$/' # semver

downstream_pytest_pve_cloud:
  stage: deploy
  needs:
    - publish_pypi
  trigger:
    project: "pve-cloud/pytest-pve-cloud"
  variables:
    PY_PVE_CLOUD: $CI_COMMIT_TAG
    UPSTREAM_TAG_MESSAGE: $CI_COMMIT_TAG_MESSAGE # here we store the type of the release
  rules:
    - if: '$CI_COMMIT_TAG =~ /^\d+\.\d+\.\d+$/' # semver

downstream_pxc_provider:
  stage: deploy
  needs:
    - publish_pypi
  trigger:
    project: "pve-cloud/terraform-provider-pxc"
  variables:
    PY_PVE_CLOUD: $CI_COMMIT_TAG
    UPSTREAM_TAG_MESSAGE: $CI_COMMIT_TAG_MESSAGE # here we store the type of the release
  rules:
    - if: '$CI_COMMIT_TAG =~ /^\d+\.\d+\.\d+$/' # semver


format_source:
  stage: build
  image: tobiashvmz/pve-cloud-pyci:2026010412
  script:
    - git config --global user.name "$GITLAB_USER_NAME"
    - git config --global user.email "$GITLAB_USER_EMAIL"
    
    - autoflake --exclude orm --in-place --recursive .
    - black --exclude orm .
    - isort --skip orm .
    # commit the changes
    - |
      if ! git diff --quiet; then
        git add .
        git commit -m "Format and cleanup pipeline"
        git push origin HEAD:$CI_COMMIT_REF_NAME
      else
        echo "Nothing to clean or format!"
      fi
  rules:
    - if: >
        $CI_COMMIT_TAG !~ /^\d+\.\d+\.\d+$/ &&
        $CI_COMMIT_TAG !~ /^release-[a-z]+$/ &&
        $CI_COMMIT_TAG !~ /^release-all-[a-z]+$/ &&
        $CI_PIPELINE_SOURCE == 'push'
      when: on_success
    - when: never